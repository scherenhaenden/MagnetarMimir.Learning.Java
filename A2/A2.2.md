### **A2.2: Inheritance Basics**

Inheritance is one of the fundamental principles of Object-Oriented Programming (OOP). It allows a new class (called a **subclass** or **child class**) to inherit fields and methods from an existing class (called a **superclass** or **parent class**).

---

#### **1. What Is Inheritance?**

**Definition**:  
Inheritance allows a class to acquire the properties and behaviors (fields and methods) of another class. It helps promote code reuse, extensibility, and maintainability.

**Syntax**:
```java
class Parent {
    // Fields and methods
}

class Child extends Parent {
    // Additional fields and methods
}
```

---

#### **2. Key Concepts of Inheritance**

1. **Superclass (Parent Class)**:
   - The class whose members are inherited by another class.
   - Example: `Animal` is the superclass of `Dog`.

2. **Subclass (Child Class)**:
   - The class that inherits members from another class.
   - Example: `Dog` is the subclass of `Animal`.

3. **`extends` Keyword**:
   - Used to indicate inheritance.
   - Example: `class Dog extends Animal { }`

---

#### **3. Features of Inheritance**

1. **Code Reusability**:
   - Common fields and methods can be defined in a superclass and reused in subclasses.

2. **Method Overriding**:
   - Subclasses can redefine methods from the superclass to provide specific functionality.

3. **`super` Keyword**:
   - Used to refer to the parent class's methods or constructors.

4. **Single Inheritance in Java**:
   - A class can only inherit from one superclass (Java does not support multiple inheritance through classes but supports it via interfaces).

---

#### **4. Example: Basic Inheritance**

**Superclass**:
```java
class Animal {
    String name;

    public void eat() {
        System.out.println(name + " is eating.");
    }
}
```

**Subclass**:
```java
class Dog extends Animal {
    public void bark() {
        System.out.println(name + " is barking.");
    }
}
```

**Main Class**:
```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "Buddy";
        dog.eat();  // Inherited from Animal
        dog.bark(); // Defined in Dog
    }
}
```

**Output**:
```
Buddy is eating.
Buddy is barking.
```

---

#### **5. Access Modifiers in Inheritance**

| **Access Modifier** | **Same Class** | **Same Package** | **Subclass (Different Package)** | **Outside Class** |
|----------------------|----------------|-------------------|-----------------------------------|--------------------|
| `public`            | ✔              | ✔                 | ✔                                 | ✔                  |
| `protected`         | ✔              | ✔                 | ✔                                 | ✘                  |
| Default (none)      | ✔              | ✔                 | ✘                                 | ✘                  |
| `private`           | ✔              | ✘                 | ✘                                 | ✘                  |

**Note**: Private fields and methods are not inherited but can be accessed indirectly via public or protected getters/setters.

---

#### **6. Using the `super` Keyword**

1. **Accessing Parent Class Methods**:
   - **Example**:
     ```java
     class Animal {
         public void sleep() {
             System.out.println("Animal is sleeping.");
         }
     }

     class Dog extends Animal {
         @Override
         public void sleep() {
             super.sleep();  // Calls parent class's method
             System.out.println("Dog is snoring.");
         }
     }

     public class Main {
         public static void main(String[] args) {
             Dog dog = new Dog();
             dog.sleep();
         }
     }
     ```

     **Output**:
     ```
     Animal is sleeping.
     Dog is snoring.
     ```

2. **Accessing Parent Class Constructors**:
   - **Example**:
     ```java
     class Animal {
         String name;

         public Animal(String name) {
             this.name = name;
         }
     }

     class Dog extends Animal {
         public Dog(String name) {
             super(name);  // Calls the constructor of the superclass
         }

         public void displayName() {
             System.out.println("Dog's name is: " + name);
         }
     }

     public class Main {
         public static void main(String[] args) {
             Dog dog = new Dog("Buddy");
             dog.displayName();
         }
     }
     ```

     **Output**:
     ```
     Dog's name is: Buddy
     ```

---

#### **7. Overriding Methods**

**Definition**:  
Method overriding occurs when a subclass provides its own implementation of a method inherited from the superclass.

**Rules**:
1. The method in the subclass must have the same name, return type, and parameters.
2. The access level of the overriding method cannot be more restrictive than the superclass's method.

**Example**:
```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound.");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Cat();
        animal.sound();  // Output: Meow
    }
}
```

---

#### **8. Final Classes and Methods**

1. **Final Class**:
   - A class declared as `final` cannot be extended.
   - **Example**:
     ```java
     final class Vehicle { }
     class Car extends Vehicle { }  // Error: Cannot extend final class
     ```

2. **Final Method**:
   - A method declared as `final` cannot be overridden.
   - **Example**:
     ```java
     class Animal {
         public final void sleep() {
             System.out.println("Animal is sleeping.");
         }
     }

     class Dog extends Animal {
         public void sleep() {  // Error: Cannot override final method
             System.out.println("Dog is sleeping.");
         }
     }
     ```

---

#### **9. Common Mistakes**

1. **Forgetting the `super` Constructor**:
   - When the superclass does not have a no-argument constructor, you must explicitly call its parameterized constructor.

2. **Overriding vs Overloading**:
   - Overriding changes behavior in a subclass; overloading creates methods with the same name but different parameters.

3. **Confusing Access Levels**:
   - Forgetting that `private` fields are not inherited.

---

#### **10. Exercises**

**Exercise 1: Create a `Vehicle` and `Car` Class**
1. Define a `Vehicle` class with:
   - Field: `speed`.
   - Method: `move()`.
2. Define a `Car` class that extends `Vehicle` and adds:
   - Field: `brand`.
   - Method: `displayInfo()`.

**Solution**:
```java
class Vehicle {
    int speed;

    public void move() {
        System.out.println("Vehicle is moving at " + speed + " km/h.");
    }
}

class Car extends Vehicle {
    String brand;

    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Speed: " + speed + " km/h.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.brand = "Toyota";
        car.speed = 120;
        car.displayInfo();
    }
}
```

**Exercise 2: Override a Method**
1. Create an `Animal` class with:
   - Method: `makeSound()`.
2. Create a `Dog` class that overrides `makeSound()`.

**Solution**:
```java
class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.makeSound();  // Output: Woof!
    }
}
```

---

#### **11. Best Practices**

1. Use inheritance only when there is a clear **is-a** relationship.
   - Example: A `Dog` **is-a** `Animal`.
2. Avoid overriding methods unless necessary.
3. Favor **composition** over inheritance for greater flexibility.
4. Always call `super()` when extending a class with a parameterized constructor.
5. Use `@Override` to ensure proper method overriding.

---

### **A2.2: Using the `super` Keyword**

The `super` keyword in Java is used to refer to the **immediate parent class** of a subclass. It is essential for working with inheritance, enabling subclasses to access and interact with the methods and constructors of their parent classes.

---

#### **1. What Is `super`?**

- **Definition**: The `super` keyword is a reference to the **immediate parent class** of the current object.
- **Purpose**:  
  1. Call a superclass constructor.
  2. Access a superclass method or field that has been overridden or hidden in the subclass.

---

#### **2. Key Uses of `super`**

1. **Accessing Superclass Methods**
2. **Accessing Superclass Fields**
3. **Calling Superclass Constructors**

---

#### **3. Accessing Superclass Methods**

You can use `super.methodName()` to call a method from the parent class.

**Example**:
```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        super.makeSound();  // Calls the parent class method
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();
    }
}
```

**Output**:
```
Animal makes a sound.
Dog barks.
```

---

#### **4. Accessing Superclass Fields**

If a field in the subclass hides a field with the same name in the superclass, you can use `super.fieldName` to access the superclass's field.

**Example**:
```java
class Animal {
    String name = "Animal";
}

class Dog extends Animal {
    String name = "Dog";

    public void displayNames() {
        System.out.println("Name in subclass: " + name);       // Refers to Dog's field
        System.out.println("Name in superclass: " + super.name); // Refers to Animal's field
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.displayNames();
    }
}
```

**Output**:
```
Name in subclass: Dog
Name in superclass: Animal
```

---

#### **5. Calling Superclass Constructors**

The `super()` keyword is used to explicitly call a constructor from the parent class.

1. **Default Constructor**:
   - If no constructor is explicitly called, Java automatically calls the default constructor of the superclass.

2. **Parameterized Constructor**:
   - Use `super(arguments)` to call a specific constructor of the superclass.

**Example**: Using `super()` for a parameterized constructor
```java
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    public Dog(String name) {
        super(name);  // Calls the superclass constructor
    }

    public void displayName() {
        System.out.println("Dog's name: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy");
        dog.displayName();
    }
}
```

**Output**:
```
Dog's name: Buddy
```

**Rules for `super()`**:
1. If a subclass constructor does not call a superclass constructor explicitly, Java inserts a default call to the no-argument constructor of the superclass.
2. `super()` must be the **first statement** in a constructor.
3. If the superclass does not have a no-argument constructor, the subclass must explicitly call a parameterized constructor using `super(arguments)`.

---

#### **6. Combining `super` for Fields, Methods, and Constructors**

**Example**:
```java
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    public void makeSound() {
        System.out.println(name + " makes a sound.");
    }
}

class Dog extends Animal {
    String breed;

    public Dog(String name, String breed) {
        super(name);  // Call to superclass constructor
        this.breed = breed;
    }

    @Override
    public void makeSound() {
        super.makeSound();  // Call to superclass method
        System.out.println(name + " barks.");
    }

    public void displayBreed() {
        System.out.println(name + " is a " + breed + ".");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy", "Golden Retriever");
        dog.makeSound();
        dog.displayBreed();
    }
}
```

**Output**:
```
Buddy makes a sound.
Buddy barks.
Buddy is a Golden Retriever.
```

---

#### **7. Common Mistakes**

1. **Misusing `super` in Static Contexts**:
   - `super` cannot be used in static methods because it refers to an instance of the class.

   **Error**:
   ```java
   public static void staticMethod() {
       super.someMethod();  // Error: Cannot use super in static context
   }
   ```

2. **Forgetting to Call the Superclass Constructor**:
   - If the superclass does not have a no-argument constructor, forgetting to call a parameterized constructor causes a compilation error.

3. **Calling `super()` After Other Statements**:
   - `super()` must be the first statement in a constructor.

---

#### **8. Exercises**

**Exercise 1: Use `super` to Access a Method**
1. Create a superclass `Vehicle` with:
   - Method: `move()` that prints "Vehicle is moving."
2. Create a subclass `Car` that:
   - Overrides `move()` to print "Car is driving."
   - Calls the superclass's `move()`.

**Solution**:
```java
class Vehicle {
    public void move() {
        System.out.println("Vehicle is moving.");
    }
}

class Car extends Vehicle {
    @Override
    public void move() {
        super.move();  // Call to superclass method
        System.out.println("Car is driving.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.move();
    }
}
```

**Output**:
```
Vehicle is moving.
Car is driving.
```

---

**Exercise 2: Use `super` to Call a Constructor**
1. Create a superclass `Person` with:
   - Field: `name`.
   - Constructor: Initializes `name`.
2. Create a subclass `Employee` with:
   - Fields: `employeeId`.
   - Constructor: Initializes `name` and `employeeId` using `super()`.

**Solution**:
```java
class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}

class Employee extends Person {
    String employeeId;

    public Employee(String name, String employeeId) {
        super(name);  // Call to superclass constructor
        this.employeeId = employeeId;
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Employee ID: " + employeeId);
    }
}

public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("Alice", "E12345");
        emp.displayInfo();
    }
}
```

**Output**:
```
Name: Alice, Employee ID: E12345
```

---

#### **9. Best Practices**

1. **Use `super` for Clear Code**:
   - Always call the superclass's constructor explicitly if it requires parameters.

2. **Avoid Overusing `super`**:
   - Use it only when necessary (e.g., when overriding or accessing hidden members).

3. **Maintain Proper Constructor Chains**:
   - Ensure constructors in subclasses properly initialize both parent and child fields.

4. **Comment Complex Uses of `super`**:
   - Document why `super` is used, especially when interacting with overridden methods.

---

