### **A2.2: Inheritance Basics**

Inheritance is one of the fundamental principles of Object-Oriented Programming (OOP). It allows a new class (called a **subclass** or **child class**) to inherit fields and methods from an existing class (called a **superclass** or **parent class**).

---

#### **1. What Is Inheritance?**

**Definition**:  
Inheritance allows a class to acquire the properties and behaviors (fields and methods) of another class. It helps promote code reuse, extensibility, and maintainability.

**Syntax**:
```java
class Parent {
    // Fields and methods
}

class Child extends Parent {
    // Additional fields and methods
}
```

---

#### **2. Key Concepts of Inheritance**

1. **Superclass (Parent Class)**:
   - The class whose members are inherited by another class.
   - Example: `Animal` is the superclass of `Dog`.

2. **Subclass (Child Class)**:
   - The class that inherits members from another class.
   - Example: `Dog` is the subclass of `Animal`.

3. **`extends` Keyword**:
   - Used to indicate inheritance.
   - Example: `class Dog extends Animal { }`

---

#### **3. Features of Inheritance**

1. **Code Reusability**:
   - Common fields and methods can be defined in a superclass and reused in subclasses.

2. **Method Overriding**:
   - Subclasses can redefine methods from the superclass to provide specific functionality.

3. **`super` Keyword**:
   - Used to refer to the parent class's methods or constructors.

4. **Single Inheritance in Java**:
   - A class can only inherit from one superclass (Java does not support multiple inheritance through classes but supports it via interfaces).

---

#### **4. Example: Basic Inheritance**

**Superclass**:
```java
class Animal {
    String name;

    public void eat() {
        System.out.println(name + " is eating.");
    }
}
```

**Subclass**:
```java
class Dog extends Animal {
    public void bark() {
        System.out.println(name + " is barking.");
    }
}
```

**Main Class**:
```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "Buddy";
        dog.eat();  // Inherited from Animal
        dog.bark(); // Defined in Dog
    }
}
```

**Output**:
```
Buddy is eating.
Buddy is barking.
```

---

#### **5. Access Modifiers in Inheritance**

| **Access Modifier** | **Same Class** | **Same Package** | **Subclass (Different Package)** | **Outside Class** |
|----------------------|----------------|-------------------|-----------------------------------|--------------------|
| `public`            | ✔              | ✔                 | ✔                                 | ✔                  |
| `protected`         | ✔              | ✔                 | ✔                                 | ✘                  |
| Default (none)      | ✔              | ✔                 | ✘                                 | ✘                  |
| `private`           | ✔              | ✘                 | ✘                                 | ✘                  |

**Note**: Private fields and methods are not inherited but can be accessed indirectly via public or protected getters/setters.

---

#### **6. Using the `super` Keyword**

1. **Accessing Parent Class Methods**:
   - **Example**:
     ```java
     class Animal {
         public void sleep() {
             System.out.println("Animal is sleeping.");
         }
     }

     class Dog extends Animal {
         @Override
         public void sleep() {
             super.sleep();  // Calls parent class's method
             System.out.println("Dog is snoring.");
         }
     }

     public class Main {
         public static void main(String[] args) {
             Dog dog = new Dog();
             dog.sleep();
         }
     }
     ```

     **Output**:
     ```
     Animal is sleeping.
     Dog is snoring.
     ```

2. **Accessing Parent Class Constructors**:
   - **Example**:
     ```java
     class Animal {
         String name;

         public Animal(String name) {
             this.name = name;
         }
     }

     class Dog extends Animal {
         public Dog(String name) {
             super(name);  // Calls the constructor of the superclass
         }

         public void displayName() {
             System.out.println("Dog's name is: " + name);
         }
     }

     public class Main {
         public static void main(String[] args) {
             Dog dog = new Dog("Buddy");
             dog.displayName();
         }
     }
     ```

     **Output**:
     ```
     Dog's name is: Buddy
     ```

---

#### **7. Overriding Methods**

**Definition**:  
Method overriding occurs when a subclass provides its own implementation of a method inherited from the superclass.

**Rules**:
1. The method in the subclass must have the same name, return type, and parameters.
2. The access level of the overriding method cannot be more restrictive than the superclass's method.

**Example**:
```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound.");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Cat();
        animal.sound();  // Output: Meow
    }
}
```

---

#### **8. Final Classes and Methods**

1. **Final Class**:
   - A class declared as `final` cannot be extended.
   - **Example**:
     ```java
     final class Vehicle { }
     class Car extends Vehicle { }  // Error: Cannot extend final class
     ```

2. **Final Method**:
   - A method declared as `final` cannot be overridden.
   - **Example**:
     ```java
     class Animal {
         public final void sleep() {
             System.out.println("Animal is sleeping.");
         }
     }

     class Dog extends Animal {
         public void sleep() {  // Error: Cannot override final method
             System.out.println("Dog is sleeping.");
         }
     }
     ```

---

#### **9. Common Mistakes**

1. **Forgetting the `super` Constructor**:
   - When the superclass does not have a no-argument constructor, you must explicitly call its parameterized constructor.

2. **Overriding vs Overloading**:
   - Overriding changes behavior in a subclass; overloading creates methods with the same name but different parameters.

3. **Confusing Access Levels**:
   - Forgetting that `private` fields are not inherited.

---

#### **10. Exercises**

**Exercise 1: Create a `Vehicle` and `Car` Class**
1. Define a `Vehicle` class with:
   - Field: `speed`.
   - Method: `move()`.
2. Define a `Car` class that extends `Vehicle` and adds:
   - Field: `brand`.
   - Method: `displayInfo()`.

**Solution**:
```java
class Vehicle {
    int speed;

    public void move() {
        System.out.println("Vehicle is moving at " + speed + " km/h.");
    }
}

class Car extends Vehicle {
    String brand;

    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Speed: " + speed + " km/h.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.brand = "Toyota";
        car.speed = 120;
        car.displayInfo();
    }
}
```

**Exercise 2: Override a Method**
1. Create an `Animal` class with:
   - Method: `makeSound()`.
2. Create a `Dog` class that overrides `makeSound()`.

**Solution**:
```java
class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.makeSound();  // Output: Woof!
    }
}
```

---

#### **11. Best Practices**

1. Use inheritance only when there is a clear **is-a** relationship.
   - Example: A `Dog` **is-a** `Animal`.
2. Avoid overriding methods unless necessary.
3. Favor **composition** over inheritance for greater flexibility.
4. Always call `super()` when extending a class with a parameterized constructor.
5. Use `@Override` to ensure proper method overriding.

---

### **A2.2: Using the `super` Keyword**

The `super` keyword in Java is used to refer to the **immediate parent class** of a subclass. It is essential for working with inheritance, enabling subclasses to access and interact with the methods and constructors of their parent classes.

---

#### **1. What Is `super`?**

- **Definition**: The `super` keyword is a reference to the **immediate parent class** of the current object.
- **Purpose**:  
  1. Call a superclass constructor.
  2. Access a superclass method or field that has been overridden or hidden in the subclass.

---

#### **2. Key Uses of `super`**

1. **Accessing Superclass Methods**
2. **Accessing Superclass Fields**
3. **Calling Superclass Constructors**

---

#### **3. Accessing Superclass Methods**

You can use `super.methodName()` to call a method from the parent class.

**Example**:
```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        super.makeSound();  // Calls the parent class method
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();
    }
}
```

**Output**:
```
Animal makes a sound.
Dog barks.
```

---

#### **4. Accessing Superclass Fields**

If a field in the subclass hides a field with the same name in the superclass, you can use `super.fieldName` to access the superclass's field.

**Example**:
```java
class Animal {
    String name = "Animal";
}

class Dog extends Animal {
    String name = "Dog";

    public void displayNames() {
        System.out.println("Name in subclass: " + name);       // Refers to Dog's field
        System.out.println("Name in superclass: " + super.name); // Refers to Animal's field
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.displayNames();
    }
}
```

**Output**:
```
Name in subclass: Dog
Name in superclass: Animal
```

---

#### **5. Calling Superclass Constructors**

The `super()` keyword is used to explicitly call a constructor from the parent class.

1. **Default Constructor**:
   - If no constructor is explicitly called, Java automatically calls the default constructor of the superclass.

2. **Parameterized Constructor**:
   - Use `super(arguments)` to call a specific constructor of the superclass.

**Example**: Using `super()` for a parameterized constructor
```java
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    public Dog(String name) {
        super(name);  // Calls the superclass constructor
    }

    public void displayName() {
        System.out.println("Dog's name: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy");
        dog.displayName();
    }
}
```

**Output**:
```
Dog's name: Buddy
```

**Rules for `super()`**:
1. If a subclass constructor does not call a superclass constructor explicitly, Java inserts a default call to the no-argument constructor of the superclass.
2. `super()` must be the **first statement** in a constructor.
3. If the superclass does not have a no-argument constructor, the subclass must explicitly call a parameterized constructor using `super(arguments)`.

---

#### **6. Combining `super` for Fields, Methods, and Constructors**

**Example**:
```java
class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    public void makeSound() {
        System.out.println(name + " makes a sound.");
    }
}

class Dog extends Animal {
    String breed;

    public Dog(String name, String breed) {
        super(name);  // Call to superclass constructor
        this.breed = breed;
    }

    @Override
    public void makeSound() {
        super.makeSound();  // Call to superclass method
        System.out.println(name + " barks.");
    }

    public void displayBreed() {
        System.out.println(name + " is a " + breed + ".");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy", "Golden Retriever");
        dog.makeSound();
        dog.displayBreed();
    }
}
```

**Output**:
```
Buddy makes a sound.
Buddy barks.
Buddy is a Golden Retriever.
```

---

#### **7. Common Mistakes**

1. **Misusing `super` in Static Contexts**:
   - `super` cannot be used in static methods because it refers to an instance of the class.

   **Error**:
   ```java
   public static void staticMethod() {
       super.someMethod();  // Error: Cannot use super in static context
   }
   ```

2. **Forgetting to Call the Superclass Constructor**:
   - If the superclass does not have a no-argument constructor, forgetting to call a parameterized constructor causes a compilation error.

3. **Calling `super()` After Other Statements**:
   - `super()` must be the first statement in a constructor.

---

#### **8. Exercises**

**Exercise 1: Use `super` to Access a Method**
1. Create a superclass `Vehicle` with:
   - Method: `move()` that prints "Vehicle is moving."
2. Create a subclass `Car` that:
   - Overrides `move()` to print "Car is driving."
   - Calls the superclass's `move()`.

**Solution**:
```java
class Vehicle {
    public void move() {
        System.out.println("Vehicle is moving.");
    }
}

class Car extends Vehicle {
    @Override
    public void move() {
        super.move();  // Call to superclass method
        System.out.println("Car is driving.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.move();
    }
}
```

**Output**:
```
Vehicle is moving.
Car is driving.
```

---

**Exercise 2: Use `super` to Call a Constructor**
1. Create a superclass `Person` with:
   - Field: `name`.
   - Constructor: Initializes `name`.
2. Create a subclass `Employee` with:
   - Fields: `employeeId`.
   - Constructor: Initializes `name` and `employeeId` using `super()`.

**Solution**:
```java
class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}

class Employee extends Person {
    String employeeId;

    public Employee(String name, String employeeId) {
        super(name);  // Call to superclass constructor
        this.employeeId = employeeId;
    }

    public void displayInfo() {
        System.out.println("Name: " + name + ", Employee ID: " + employeeId);
    }
}

public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("Alice", "E12345");
        emp.displayInfo();
    }
}
```

**Output**:
```
Name: Alice, Employee ID: E12345
```

---

#### **9. Best Practices**

1. **Use `super` for Clear Code**:
   - Always call the superclass's constructor explicitly if it requires parameters.

2. **Avoid Overusing `super`**:
   - Use it only when necessary (e.g., when overriding or accessing hidden members).

3. **Maintain Proper Constructor Chains**:
   - Ensure constructors in subclasses properly initialize both parent and child fields.

4. **Comment Complex Uses of `super`**:
   - Document why `super` is used, especially when interacting with overridden methods.

---

### **A2.2: Polymorphism Introduction**

Polymorphism is one of the four core principles of Object-Oriented Programming (OOP), along with encapsulation, inheritance, and abstraction. It allows one interface to be used for different underlying forms (data types or classes).

---

#### **1. What Is Polymorphism?**

**Definition**:  
Polymorphism means **"many forms"**. It enables objects to be treated as instances of their parent class, allowing a single interface to represent multiple types.

**Types of Polymorphism in Java**:
1. **Compile-time Polymorphism** (Method Overloading)
2. **Runtime Polymorphism** (Method Overriding)

---

#### **2. Compile-time Polymorphism (Method Overloading)**

**Definition**:  
Occurs when multiple methods in the same class share the same name but differ in:
- Number of parameters.
- Types of parameters.

**Example**:
```java
class Calculator {
    // Overloaded methods
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(2, 3));          // Calls first method
        System.out.println(calc.add(2.5, 3.5));      // Calls second method
        System.out.println(calc.add(1, 2, 3));       // Calls third method
    }
}
```

**Output**:
```
5
6.0
6
```

**Key Points**:
- Method overloading is resolved at **compile time**.
- It enhances program readability and flexibility.

---

#### **3. Runtime Polymorphism (Method Overriding)**

**Definition**:  
Occurs when a subclass provides a specific implementation for a method already defined in its superclass.

**Example**:
```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks.");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows.");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog();  // Upcasting
        Animal animal2 = new Cat();

        animal1.makeSound();  // Calls Dog's version
        animal2.makeSound();  // Calls Cat's version
    }
}
```

**Output**:
```
Dog barks.
Cat meows.
```

**Key Points**:
- Method overriding is resolved at **runtime**.
- It is used when behavior depends on the object's actual type, not the reference type.

---

#### **4. Polymorphism via Interfaces**

An interface allows multiple classes to implement the same behavior, promoting polymorphism.

**Example**:
```java
interface Shape {
    void draw();
}

class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle.");
    }
}

class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle.");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape1 = new Circle();
        Shape shape2 = new Rectangle();

        shape1.draw();  // Calls Circle's implementation
        shape2.draw();  // Calls Rectangle's implementation
    }
}
```

**Output**:
```
Drawing a Circle.
Drawing a Rectangle.
```

**Key Points**:
- Interfaces provide a way to achieve polymorphism without inheritance.
- The object’s actual type determines which method is executed.

---

#### **5. Real-world Analogy**

**Polymorphism Example in Real Life**:
- Imagine a general `Vehicle` type.
- A `Car` and a `Bike` are both `Vehicles`, but they behave differently when driven.

```java
class Vehicle {
    public void drive() {
        System.out.println("Vehicle is being driven.");
    }
}

class Car extends Vehicle {
    @Override
    public void drive() {
        System.out.println("Car is being driven.");
    }
}

class Bike extends Vehicle {
    @Override
    public void drive() {
        System.out.println("Bike is being ridden.");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle car = new Car();
        Vehicle bike = new Bike();

        car.drive();
        bike.drive();
    }
}
```

**Output**:
```
Car is being driven.
Bike is being ridden.
```

---

#### **6. Dynamic Method Dispatch**

**Definition**:  
Dynamic Method Dispatch is the mechanism by which a call to an overridden method is resolved at runtime, based on the object's actual type.

**Example**:
```java
class Parent {
    public void show() {
        System.out.println("Parent class");
    }
}

class Child extends Parent {
    @Override
    public void show() {
        System.out.println("Child class");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();  // Upcasting
        obj.show();  // Calls Child's version
    }
}
```

**Output**:
```
Child class
```

---

#### **7. Common Mistakes**

1. **Misunderstanding Overloading vs Overriding**:
   - Overloading: Same class, different parameter lists.
   - Overriding: Subclass redefines superclass method.

2. **Confusing Reference Type and Object Type**:
   - **Example**:
     ```java
     Animal animal = new Dog();
     animal.bark();  // Error: Cannot call bark() because Animal does not define it
     ```

3. **Forgetting `@Override` Annotation**:
   - Adding `@Override` helps ensure you are overriding a method and not introducing a new one accidentally.

---

#### **8. Exercises**

**Exercise 1: Method Overloading**
1. Create a `MathUtils` class with overloaded `multiply` methods:
   - `multiply(int a, int b)`
   - `multiply(double a, double b)`

**Solution**:
```java
class MathUtils {
    public int multiply(int a, int b) {
        return a * b;
    }

    public double multiply(double a, double b) {
        return a * b;
    }
}

public class Main {
    public static void main(String[] args) {
        MathUtils utils = new MathUtils();
        System.out.println(utils.multiply(5, 4));       // Output: 20
        System.out.println(utils.multiply(2.5, 3.5));  // Output: 8.75
    }
}
```

---

**Exercise 2: Method Overriding**
1. Create a `Shape` superclass with a `draw()` method.
2. Create `Circle` and `Square` subclasses that override `draw()`.

**Solution**:
```java
class Shape {
    public void draw() {
        System.out.println("Drawing a shape.");
    }
}

class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle.");
    }
}

class Square extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Square.");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape1 = new Circle();
        Shape shape2 = new Square();

        shape1.draw();  // Output: Drawing a Circle.
        shape2.draw();  // Output: Drawing a Square.
    }
}
```

---

#### **9. Best Practices**

1. **Use `@Override`**:
   - Always annotate overridden methods to ensure correctness.
   
2. **Prefer Abstract Classes or Interfaces**:
   - For achieving runtime polymorphism in complex systems, use abstract classes or interfaces.

3. **Avoid Overloading Ambiguity**:
   - Overloaded methods should differ clearly in parameter type or count.

4. **Use Polymorphism for Flexibility**:
   - Design APIs to operate on parent class references, enabling easier extensibility.

---

### **A2.2: Encapsulation**

**Encapsulation** is one of the foundational principles of Object-Oriented Programming (OOP). It combines data (fields) and behavior (methods) into a single unit (class) while restricting direct access to the data to ensure controlled and secure interactions.

---

#### **1. What Is Encapsulation?**

- **Definition**: Encapsulation is the process of wrapping data (fields) and methods (behavior) together in a single unit and protecting the data from unauthorized access or modification.
- **Goal**: Achieve better control, security, and maintainability by exposing only necessary details and keeping the rest hidden.

---

#### **2. Key Features of Encapsulation**

1. **Data Hiding**:
   - Use access modifiers (e.g., `private`, `protected`) to restrict access to fields.
   - Keep fields private and provide controlled access through public methods (getters and setters).

2. **Abstraction**:
   - Encapsulation supports abstraction by hiding the internal details and exposing only the necessary functionality.

3. **Control**:
   - Control how data is accessed or modified by adding validation or logic in the methods.

---

#### **3. Advantages of Encapsulation**

1. **Security**:
   - Prevent unauthorized access to sensitive data.
2. **Flexibility**:
   - Modify the internal implementation without affecting external code.
3. **Reusability**:
   - Encapsulated classes are easier to use and reuse in different scenarios.
4. **Maintainability**:
   - Makes the code easier to debug and update.

---

#### **4. Encapsulation in Action**

Encapsulation is implemented using:
1. **Private Fields**:
   - Keep the class fields private to restrict direct access.
2. **Public Methods**:
   - Provide getters and setters to control and validate access.

**Example**: Bank Account Class
```java
public class BankAccount {
    private double balance;  // Private field

    // Constructor to initialize balance
    public BankAccount(double initialBalance) {
        if (initialBalance > 0) {
            this.balance = initialBalance;
        }
    }

    // Getter for balance
    public double getBalance() {
        return balance;
    }

    // Setter for deposit
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        } else {
            System.out.println("Deposit amount must be positive.");
        }
    }

    // Setter for withdrawal
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
        } else {
            System.out.println("Invalid withdrawal amount.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(100);
        System.out.println("Initial Balance: " + account.getBalance());

        account.deposit(50);
        System.out.println("After Deposit: " + account.getBalance());

        account.withdraw(30);
        System.out.println("After Withdrawal: " + account.getBalance());
    }
}
```

**Output**:
```
Initial Balance: 100.0
After Deposit: 150.0
After Withdrawal: 120.0
```

---

#### **5. Access Modifiers and Encapsulation**

| **Modifier**   | **Class** | **Package** | **Subclass** | **World** |
|-----------------|-----------|-------------|--------------|-----------|
| `public`       | ✔         | ✔           | ✔            | ✔         |
| `protected`    | ✔         | ✔           | ✔            | ✘         |
| Default (none) | ✔         | ✔           | ✘            | ✘         |
| `private`      | ✔         | ✘           | ✘            | ✘         |

**Best Practice**:
- Use `private` for fields and provide public or protected getters and setters for controlled access.

---

#### **6. Adding Validation in Getters and Setters**

Encapsulation allows you to include logic in getter and setter methods to validate data before assigning it.

**Example**: Student Class with Validation
```java
public class Student {
    private String name;
    private int age;

    // Getter for name
    public String getName() {
        return name;
    }

    // Setter for name with validation
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        } else {
            System.out.println("Invalid name.");
        }
    }

    // Getter for age
    public int getAge() {
        return age;
    }

    // Setter for age with validation
    public void setAge(int age) {
        if (age > 0 && age <= 150) {
            this.age = age;
        } else {
            System.out.println("Invalid age.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Student student = new Student();
        student.setName("Alice");
        student.setAge(20);

        System.out.println("Name: " + student.getName());
        System.out.println("Age: " + student.getAge());

        student.setName("");  // Invalid name
        student.setAge(-5);   // Invalid age
    }
}
```

**Output**:
```
Name: Alice
Age: 20
Invalid name.
Invalid age.
```

---

#### **7. Real-world Analogy**

**Encapsulation Example**:
- A **TV Remote** encapsulates its internal components and only exposes the buttons for interaction. You don’t need to know how the remote works internally, just how to use it.

**Java Code Representation**:
```java
public class RemoteControl {
    private boolean isOn = false;

    // Encapsulation ensures you control interaction
    public void pressPowerButton() {
        isOn = !isOn;
        if (isOn) {
            System.out.println("TV is ON");
        } else {
            System.out.println("TV is OFF");
        }
    }
}
```

---

#### **8. Common Mistakes**

1. **Not Using Private Fields**:
   - Directly exposing fields without using getters and setters breaks encapsulation.
   - **Avoid**:
     ```java
     public String name;  // Bad practice
     ```

2. **Over-Exposing Methods**:
   - Unnecessarily making methods public can lead to misuse.

3. **Skipping Validation**:
   - Neglecting to validate inputs in setters can lead to unexpected results.

4. **Breaking Encapsulation**:
   - Allowing direct access to private fields through public references.

---

#### **9. Exercises**

**Exercise 1: Create a `Book` Class**
1. Fields: `title`, `author`, `price`.
2. Use private fields and provide public getters and setters.
3. Add validation to ensure the price is positive.

**Solution**:
```java
public class Book {
    private String title;
    private String author;
    private double price;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        if (title != null && !title.trim().isEmpty()) {
            this.title = title;
        } else {
            System.out.println("Invalid title.");
        }
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        if (author != null && !author.trim().isEmpty()) {
            this.author = author;
        } else {
            System.out.println("Invalid author.");
        }
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        if (price > 0) {
            this.price = price;
        } else {
            System.out.println("Price must be positive.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Book book = new Book();
        book.setTitle("1984");
        book.setAuthor("George Orwell");
        book.setPrice(15.99);

        System.out.println("Title: " + book.getTitle());
        System.out.println("Author: " + book.getAuthor());
        System.out.println("Price: $" + book.getPrice());
    }
}
```

---

**Exercise 2: Create a `Person` Class**
1. Fields: `firstName`, `lastName`, `age`.
2. Create a `getFullName()` method that combines `firstName` and `lastName`.
3. Add validation for all fields.

**Solution**:
```java
public class Person {
    private String firstName;
    private String lastName;
    private int age;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        if (firstName != null && !firstName.trim().isEmpty()) {
            this.firstName = firstName;
        } else {
            System.out.println("Invalid first name.");
        }
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        if (lastName != null && !lastName.trim().isEmpty()) {
            this.lastName = lastName;
        } else {
            System.out.println("Invalid last name.");
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age > 0 && age <= 150) {
            this.age = age;
        } else {
            System.out.println("Invalid age.");
        }
    }

    public String getFullName() {
        return firstName + " " + lastName;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setFirstName("John");
        person.setLastName("Doe");
        person.setAge(35);

        System.out.println("Full Name: " + person.getFullName());
        System.out.println("Age: " + person.getAge());
    }
}
```

---

#### **10. Best Practices**

1. **Use Private Fields**:
   - Always keep fields private to ensure encapsulation.

2. **Validate Input**:
   - Add validation logic to setters to ensure data consistency.

3. **Expose Only Necessary Methods**:
   - Avoid exposing methods that are not required by other classes.

4. **Keep Getters and Setters Simple**:
   - Unless validation or logic is needed, keep these methods concise.

---

