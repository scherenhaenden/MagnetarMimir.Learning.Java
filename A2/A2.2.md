### **A2.2: Inheritance Basics**

Inheritance is one of the fundamental principles of Object-Oriented Programming (OOP). It allows a new class (called a **subclass** or **child class**) to inherit fields and methods from an existing class (called a **superclass** or **parent class**).

---

#### **1. What Is Inheritance?**

**Definition**:  
Inheritance allows a class to acquire the properties and behaviors (fields and methods) of another class. It helps promote code reuse, extensibility, and maintainability.

**Syntax**:
```java
class Parent {
    // Fields and methods
}

class Child extends Parent {
    // Additional fields and methods
}
```

---

#### **2. Key Concepts of Inheritance**

1. **Superclass (Parent Class)**:
   - The class whose members are inherited by another class.
   - Example: `Animal` is the superclass of `Dog`.

2. **Subclass (Child Class)**:
   - The class that inherits members from another class.
   - Example: `Dog` is the subclass of `Animal`.

3. **`extends` Keyword**:
   - Used to indicate inheritance.
   - Example: `class Dog extends Animal { }`

---

#### **3. Features of Inheritance**

1. **Code Reusability**:
   - Common fields and methods can be defined in a superclass and reused in subclasses.

2. **Method Overriding**:
   - Subclasses can redefine methods from the superclass to provide specific functionality.

3. **`super` Keyword**:
   - Used to refer to the parent class's methods or constructors.

4. **Single Inheritance in Java**:
   - A class can only inherit from one superclass (Java does not support multiple inheritance through classes but supports it via interfaces).

---

#### **4. Example: Basic Inheritance**

**Superclass**:
```java
class Animal {
    String name;

    public void eat() {
        System.out.println(name + " is eating.");
    }
}
```

**Subclass**:
```java
class Dog extends Animal {
    public void bark() {
        System.out.println(name + " is barking.");
    }
}
```

**Main Class**:
```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "Buddy";
        dog.eat();  // Inherited from Animal
        dog.bark(); // Defined in Dog
    }
}
```

**Output**:
```
Buddy is eating.
Buddy is barking.
```

---

#### **5. Access Modifiers in Inheritance**

| **Access Modifier** | **Same Class** | **Same Package** | **Subclass (Different Package)** | **Outside Class** |
|----------------------|----------------|-------------------|-----------------------------------|--------------------|
| `public`            | ✔              | ✔                 | ✔                                 | ✔                  |
| `protected`         | ✔              | ✔                 | ✔                                 | ✘                  |
| Default (none)      | ✔              | ✔                 | ✘                                 | ✘                  |
| `private`           | ✔              | ✘                 | ✘                                 | ✘                  |

**Note**: Private fields and methods are not inherited but can be accessed indirectly via public or protected getters/setters.

---

#### **6. Using the `super` Keyword**

1. **Accessing Parent Class Methods**:
   - **Example**:
     ```java
     class Animal {
         public void sleep() {
             System.out.println("Animal is sleeping.");
         }
     }

     class Dog extends Animal {
         @Override
         public void sleep() {
             super.sleep();  // Calls parent class's method
             System.out.println("Dog is snoring.");
         }
     }

     public class Main {
         public static void main(String[] args) {
             Dog dog = new Dog();
             dog.sleep();
         }
     }
     ```

     **Output**:
     ```
     Animal is sleeping.
     Dog is snoring.
     ```

2. **Accessing Parent Class Constructors**:
   - **Example**:
     ```java
     class Animal {
         String name;

         public Animal(String name) {
             this.name = name;
         }
     }

     class Dog extends Animal {
         public Dog(String name) {
             super(name);  // Calls the constructor of the superclass
         }

         public void displayName() {
             System.out.println("Dog's name is: " + name);
         }
     }

     public class Main {
         public static void main(String[] args) {
             Dog dog = new Dog("Buddy");
             dog.displayName();
         }
     }
     ```

     **Output**:
     ```
     Dog's name is: Buddy
     ```

---

#### **7. Overriding Methods**

**Definition**:  
Method overriding occurs when a subclass provides its own implementation of a method inherited from the superclass.

**Rules**:
1. The method in the subclass must have the same name, return type, and parameters.
2. The access level of the overriding method cannot be more restrictive than the superclass's method.

**Example**:
```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound.");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Cat();
        animal.sound();  // Output: Meow
    }
}
```

---

#### **8. Final Classes and Methods**

1. **Final Class**:
   - A class declared as `final` cannot be extended.
   - **Example**:
     ```java
     final class Vehicle { }
     class Car extends Vehicle { }  // Error: Cannot extend final class
     ```

2. **Final Method**:
   - A method declared as `final` cannot be overridden.
   - **Example**:
     ```java
     class Animal {
         public final void sleep() {
             System.out.println("Animal is sleeping.");
         }
     }

     class Dog extends Animal {
         public void sleep() {  // Error: Cannot override final method
             System.out.println("Dog is sleeping.");
         }
     }
     ```

---

#### **9. Common Mistakes**

1. **Forgetting the `super` Constructor**:
   - When the superclass does not have a no-argument constructor, you must explicitly call its parameterized constructor.

2. **Overriding vs Overloading**:
   - Overriding changes behavior in a subclass; overloading creates methods with the same name but different parameters.

3. **Confusing Access Levels**:
   - Forgetting that `private` fields are not inherited.

---

#### **10. Exercises**

**Exercise 1: Create a `Vehicle` and `Car` Class**
1. Define a `Vehicle` class with:
   - Field: `speed`.
   - Method: `move()`.
2. Define a `Car` class that extends `Vehicle` and adds:
   - Field: `brand`.
   - Method: `displayInfo()`.

**Solution**:
```java
class Vehicle {
    int speed;

    public void move() {
        System.out.println("Vehicle is moving at " + speed + " km/h.");
    }
}

class Car extends Vehicle {
    String brand;

    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Speed: " + speed + " km/h.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.brand = "Toyota";
        car.speed = 120;
        car.displayInfo();
    }
}
```

**Exercise 2: Override a Method**
1. Create an `Animal` class with:
   - Method: `makeSound()`.
2. Create a `Dog` class that overrides `makeSound()`.

**Solution**:
```java
class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.makeSound();  // Output: Woof!
    }
}
```

---

#### **11. Best Practices**

1. Use inheritance only when there is a clear **is-a** relationship.
   - Example: A `Dog` **is-a** `Animal`.
2. Avoid overriding methods unless necessary.
3. Favor **composition** over inheritance for greater flexibility.
4. Always call `super()` when extending a class with a parameterized constructor.
5. Use `@Override` to ensure proper method overriding.

---
