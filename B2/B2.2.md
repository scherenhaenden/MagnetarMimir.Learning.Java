### **B2.1: Advanced OOP Concepts**

Advanced Object-Oriented Programming (OOP) concepts build upon basic OOP principles like inheritance, encapsulation, and polymorphism, enabling more sophisticated and reusable code structures. This section covers **Inner Classes**, **Annotations**, and **Reflection**.

---

#### **1. Inner Classes**

Inner classes are classes defined within another class. They are used to logically group classes that will only be used within their enclosing class or for event handling.

##### **A. Types of Inner Classes**

1. **Non-static Inner Classes**:
   - Can access members (including private) of the enclosing class.
   - Associated with an instance of the outer class.

   **Example**:
   ```java
   class Outer {
       private String message = "Hello, Inner Class!";

       class Inner {
           void display() {
               System.out.println(message);
           }
       }
   }

   public class Main {
       public static void main(String[] args) {
           Outer outer = new Outer();
           Outer.Inner inner = outer.new Inner();
           inner.display();
       }
   }
   ```

   **Output**:
   ```
   Hello, Inner Class!
   ```

2. **Static Nested Classes**:
   - Does not require an instance of the outer class.
   - Can only access static members of the outer class.

   **Example**:
   ```java
   class Outer {
       static class Nested {
           void display() {
               System.out.println("Static Nested Class");
           }
       }
   }

   public class Main {
       public static void main(String[] args) {
           Outer.Nested nested = new Outer.Nested();
           nested.display();
       }
   }
   ```

   **Output**:
   ```
   Static Nested Class
   ```

3. **Local Inner Classes**:
   - Defined inside a method or block.
   - Scope is limited to the enclosing method or block.

   **Example**:
   ```java
   class Outer {
       void outerMethod() {
           class Local {
               void display() {
                   System.out.println("Local Inner Class");
               }
           }
           Local local = new Local();
           local.display();
       }
   }

   public class Main {
       public static void main(String[] args) {
           Outer outer = new Outer();
           outer.outerMethod();
       }
   }
   ```

   **Output**:
   ```
   Local Inner Class
   ```

4. **Anonymous Classes**:
   - Used to create a one-time implementation of an interface or abstract class.
   - No explicit class definition is required.

   **Example**:
   ```java
   interface Greeting {
       void sayHello();
   }

   public class Main {
       public static void main(String[] args) {
           Greeting greeting = new Greeting() {
               @Override
               public void sayHello() {
                   System.out.println("Hello, Anonymous Class!");
               }
           };
           greeting.sayHello();
       }
   }
   ```

   **Output**:
   ```
   Hello, Anonymous Class!
   ```

---

#### **2. Annotations**

Annotations are metadata that provide information about the code without affecting its execution. They are widely used for frameworks, code analysis tools, and runtime behaviors.

##### **A. Built-in Annotations**

1. **`@Override`**:
   - Ensures a method overrides a superclass method.
   - Compilation fails if the method does not override correctly.

   **Example**:
   ```java
   class Parent {
       void display() {}
   }

   class Child extends Parent {
       @Override
       void display() {
           System.out.println("Overridden Method");
       }
   }
   ```

2. **`@Deprecated`**:
   - Marks a method or class as outdated.
   - Generates warnings when used.

   **Example**:
   ```java
   @Deprecated
   void oldMethod() {
       System.out.println("Deprecated Method");
   }
   ```

3. **`@SuppressWarnings`**:
   - Suppresses specific warnings during compilation.

   **Example**:
   ```java
   @SuppressWarnings("unchecked")
   void useRawTypes() {
       List list = new ArrayList(); // Raw type warning suppressed
       list.add("example");
   }
   ```

##### **B. Custom Annotations**

1. **Defining Custom Annotations**:
   - Use the `@interface` keyword.

   **Example**:
   ```java
   @interface MyAnnotation {
       String value();
   }
   ```

2. **Using Custom Annotations**:
   - Apply the annotation to a class, method, or field.

   **Example**:
   ```java
   @MyAnnotation(value = "Custom Annotation Example")
   public class Main {
       public static void main(String[] args) {
           System.out.println("Custom Annotation Example");
       }
   }
   ```

---

#### **3. Reflection**

Reflection is a powerful feature in Java that allows inspection and manipulation of classes, methods, and fields at runtime.

##### **A. Key Features of Reflection**

1. **Inspecting Class Information**:
   - Retrieve metadata about classes, methods, constructors, and fields.

   **Example**:
   ```java
   import java.lang.reflect.Method;

   public class Main {
       public static void main(String[] args) throws ClassNotFoundException {
           Class<?> clazz = Class.forName("java.util.ArrayList");
           Method[] methods = clazz.getDeclaredMethods();

           for (Method method : methods) {
               System.out.println(method.getName());
           }
       }
   }
   ```

2. **Accessing Private Members**:
   - Reflection can override access restrictions.

   **Example**:
   ```java
   import java.lang.reflect.Field;

   class Sample {
       private String secret = "Reflection Access";
   }

   public class Main {
       public static void main(String[] args) throws Exception {
           Sample sample = new Sample();
           Field field = sample.getClass().getDeclaredField("secret");
           field.setAccessible(true); // Bypass access control
           System.out.println("Secret: " + field.get(sample));
       }
   }
   ```

   **Output**:
   ```
   Secret: Reflection Access
   ```

3. **Invoking Methods Dynamically**:
   - Call methods without knowing them at compile time.

   **Example**:
   ```java
   import java.lang.reflect.Method;

   class Sample {
       void sayHello() {
           System.out.println("Hello, Reflection!");
       }
   }

   public class Main {
       public static void main(String[] args) throws Exception {
           Sample sample = new Sample();
           Method method = sample.getClass().getMethod("sayHello");
           method.invoke(sample);
       }
   }
   ```

   **Output**:
   ```
   Hello, Reflection!
   ```

---

#### **4. Exercises**

**Exercise 1: Inner Classes**
1. Create an outer class with a non-static inner class.
2. Instantiate the inner class and call a method that prints a message.

---

**Exercise 2: Custom Annotations**
1. Define an annotation `@Info` with `author` and `date` attributes.
2. Annotate a class with this annotation.

---

**Exercise 3: Reflection**
1. Create a class with a private field.
2. Use reflection to read and modify the private field.

---

#### **5. Best Practices**

1. **Use Inner Classes Judiciously**:
   - Prefer static nested classes if the inner class doesnâ€™t require access to instance members of the outer class.

2. **Leverage Annotations for Metadata**:
   - Use annotations to simplify configurations in frameworks and tools.

3. **Be Cautious with Reflection**:
   - Reflection can bypass encapsulation, leading to security risks. Use it sparingly.

---

This detailed guide covers **Advanced OOP Concepts**, including practical examples and exercises for mastering **Inner Classes**, **Annotations**, and **Reflection**. Let me know if you'd like additional explanations or advanced examples! ðŸš€